import groovyx.net.http.OkHttpEncoders
import groovyx.net.http.FromServer
import static groovyx.net.http.HttpBuilder.configure
import static groovyx.net.http.MultipartContent.multipart
import static groovyx.net.http.util.SslUtils.ignoreSslIssues

apply plugin: 'java'

def javaVersion = JavaVersion.VERSION_1_8
sourceCompatibility = javaVersion
targetCompatibility = javaVersion

buildscript {
  repositories {
    jcenter()
  }

  dependencies {
    classpath 'com.github.jengelman.gradle.plugins:shadow:2.0.4'
    classpath 'io.github.http-builder-ng:http-builder-ng-okhttp:1.0.3'
    classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.2'
  }
}
apply plugin: 'com.github.johnrengelman.shadow'

subprojects {
  apply from: "$rootDir/gradle/dependencies.gradle"
  apply from: "$rootDir/gradle/integration.gradle"

  configurations.all {
    resolutionStrategy {
      depLibs.each { k, v -> force(v) }
    }
  }

  repositories {
    jcenter()
    maven {
      name "Splunk Mirror - External"
      url "https://splunk.jfrog.io/artifactory/maven-splunk-release/"
    }
  }

  if (JavaVersion.current() != javaVersion) {
    throw new GradleException("Wrong Java version: required is "
            + javaVersion + ", but found " + JavaVersion.current())
  }
}

task getPlugins() {
  doLast {
    def token = null
    if (project.properties.get('SCLOUD_TOKEN_FILE')?.trim()) {
      token = readToken()
    }

    def http = getHttpConfig()

    http.get {
      request.uri.path = getUploadServicePath()
      if (token != null) {
        request.headers['Authorization'] = "Bearer ${token}"
      }
      response.success { fromServer, body ->
        println body
      }
      response.failure { fromServer, body ->
        def msg = httpErrorMsg("Error fetching plugins", fromServer, body)
        throw new GradleException(msg)
      }
    }
  }
}

task registerPlugin() {
  doLast {
    def token = null
    if (project.properties.get('SCLOUD_TOKEN_FILE')?.trim()) {
      token = readToken()
    }

    def http = getHttpConfig()

    def name = project.properties.get('SDK_PLUGIN_NAME')
    def desc = project.properties.get('SDK_PLUGIN_DESC') ?: ''

    http.post {
      request.uri.path = getUploadServicePath()
      request.contentType = 'application/json'

      if (token != null) {
        request.headers['Authorization'] = "Bearer ${token}"
      }
      
      request.body = "{\"name\": \"${name}\", \"description\": \"${desc}\"}"
      response.success { fromServer, body ->
        println "Registered plugin: ${name}. Response: ${body}"
      }
      response.failure { fromServer, body ->
        def msg = httpErrorMsg("Error registering plugin ${name}", fromServer, body)
        throw new GradleException(msg)
      }
    }
  }
}

task uploadPlugin() {
  doLast {
    def pluginIdProperty = 'PLUGIN_ID'
    def pluginModule = 'PLUGIN_MODULE'

    if (!project.hasProperty(pluginIdProperty)) {
      throw new InvalidUserDataException("Must specify plugin id via gradle property: ${pluginIdProperty}")
    }

    def id = project.properties.get(pluginIdProperty)
    def module = "dsp-plugin-functions"
    if (project.hasProperty(pluginModule)) {
      module = project.properties.get(pluginModule)
    }
    File plugin = new File("${module}/build/libs/${module}.jar")

    def token = null
    if (project.properties.get('SCLOUD_TOKEN_FILE')?.trim()) {
      token = readToken()
    }

    def http = getHttpConfig()

    http.post {
      request.uri.path = "${getUploadServicePath()}/${id}/upload"
      request.contentType = 'multipart/form-data'

      if (token != null) {
        request.headers['Authorization'] = "Bearer ${token}"
      }

      request.body = multipart {
        part 'pluginJar', 'data-pipelines-plugin-template.jar', 'application/octet-stream', plugin
      }
      request.encoder 'multipart/form-data', OkHttpEncoders.&multipart
      response.success { fromServer, body ->
        println "Uploaded jar file for plugin ID: ${id}"
      }
      response.failure { fromServer, body ->
        def msg = httpErrorMsg("Error uploading plugin ${name}", fromServer, body)
        throw new GradleException(msg)
      }
    }
  }
}

task deletePlugin() {
  doLast {
    def pluginIdProperty = 'PLUGIN_ID'
    if (!project.hasProperty(pluginIdProperty)) {
      throw new InvalidUserDataException("Must specify plugin id via gradle property: ${pluginIdProperty}")
    }
    def id = project.properties.get(pluginIdProperty)

    def token = null
    if (project.properties.get('SCLOUD_TOKEN_FILE')?.trim()) {
      token = readToken()
    }

    def http = getHttpConfig()

    http.delete {
      request.uri.path = "${getUploadServicePath()}/${id}"

      if (token != null) {
        request.headers['Authorization'] = "Bearer ${token}"
      }

      response.success { fromServer, body ->
        println "Deleted plugin with ID: ${id}"
      }
      response.failure { fromServer, body ->
        def msg = httpErrorMsg("Error deleting plugin with ID: ${id}", fromServer, body)
        throw new GradleException(msg)
      }
    }
  }
}

task createPluginJar(dependsOn: shadowJar) {
  group 'build'
  description 'Create a plugin jar packaged with dependencies'
}

// Run this task to create initial project template.
task expandTemplates(type: Copy) {
  group 'templates'
  description 'Perform initial template expansion. Will overwrite any existing source.'

  // expands files from the given path to the src directory
  // now allows multiple functions in one plugin
  from ("${project.rootDir}/${project.properties.get('SDK_FUNCTIONS_PATH')}/src") {
    expand(project.properties)
  }
  into "${project.rootDir}/dsp-plugin-functions/src"
  outputs.upToDateWhen { false }
}

ext.renameJavaFile = { String dir, String templateName, String newFilename ->
  if (!dir.endsWith('/')) {
    throw new InvalidUserDataException("directory should end in slash: " + dir)
  }
  file(dir+templateName).renameTo(file(dir+newFilename))
}

ext.addLine = { String filename, String newLine ->
  def lineFound = false
  def file = new File(filename)
  file.createNewFile() // create file if doesn't exist

  file.readLines().each { line ->
    if (line.trim() == newLine) {
      lineFound = true
    }
  }
  if (!lineFound) {
    file.append(newLine+"\n")
  }
}

ext.readToken = {
  String tokenFileProperty = "SCLOUD_TOKEN_FILE"
  if (!project.hasProperty(tokenFileProperty)) {
    throw new InvalidUserDataException("Missing required gradle property: ${tokenFileProperty}")
  }
  String fileName = project.properties.get(tokenFileProperty)
  File tokenFile = new File(fileName)
  if (tokenFile.text.isEmpty()) {
    throw new InvalidUserDataException("Token file is empty. File: ${fileName}")
  }
  return tokenFile.text.trim()
}

ext.httpErrorMsg = { String msg, FromServer fs, Object body ->
  return "${msg}. Status code: ${fs.getStatusCode().toString()}. Response: ${body}"
}

ext.getHttpConfig = {
  def insecure = project.properties.get('PLUGIN_UPLOAD_INSECURE')
  if (insecure.toString().toBoolean()) {
    return configure {
      ignoreSslIssues execution
      request.uri = getUploadServiceURI()
    }
  } else {
    return configure {
      request.uri = getUploadServiceURI()
    }
  }
}

ext.getUploadServiceURI = {
  def proto = project.properties.get('PLUGIN_UPLOAD_SERVICE_PROTOCOL')
  def host = project.properties.get('PLUGIN_UPLOAD_SERVICE_HOST')
  def port = project.properties.get('PLUGIN_UPLOAD_SERVICE_PORT')
  return "${proto}://${host}:${port}/"
}

ext.getUploadServicePath = {
  def tenant = project.properties.get('TENANT_NAME') ?: 'default'
  def endpoint = project.properties.get('PLUGIN_UPLOAD_SERVICE_ENDPOINT')
  return "/${tenant}/${endpoint}"
}
